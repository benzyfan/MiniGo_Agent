import os
import sys
import time
import subprocess
import numpy as np
import optuna

# Constants
BOARD_SIZE = 5  # Size of the Go board (5x5)
MAX_MOVES = 24  # Maximum number of moves per game
TIME_LIMIT = 50  # Time limit per move in seconds
KOMI = 2.5  # Compensation points for White

# Configuration
OPPONENTS_FILE = 'test_opponents.txt'  # File listing all opponent commands or script names
TOP_N = 10  # Number of top parameter sets to retain
GAMES_PER_COMBINATION = 15  # Number of games per parameter set against each opponent (split as needed)

def load_opponents(file_path=OPPONENTS_FILE):
    """
    Load opponents' commands or script names from a configuration file.

    Args:
        file_path (str): Path to the opponents configuration file.

    Returns:
        list: A list of opponent commands or script names.

    Exits:
        If the configuration file does not exist.
    """
    if not os.path.exists(file_path):
        print(f"Opponents configuration file '{file_path}' not found.")
        sys.exit(1)
    with open(file_path, 'r') as f:
        opponents = [line.strip() for line in f if line.strip()]
    return opponents

# Load opponent commands at the start
OPPONENT_COMMANDS = load_opponents()

def initialize_board():
    """
    Initialize an empty Go board.

    Returns:
        numpy.ndarray: A BOARD_SIZE x BOARD_SIZE board initialized to zeros.
    """
    return np.zeros((BOARD_SIZE, BOARD_SIZE), dtype=int)

def read_output(output_path='output.txt'):
    """
    Read the player's move from the output file.

    Args:
        output_path (str): Path to the output file generated by the player.

    Returns:
        tuple or str or None: The move as (x, y), 'PASS', or None if an error occurs.
    """
    try:
        with open(output_path, 'r') as f:
            content = f.read().strip()
            if content == 'PASS':
                return 'PASS'
            else:
                x_str, y_str = content.split(',')
                return int(x_str), int(y_str)
    except Exception as e:
        print(f"Error reading {output_path}: {e}")
        return None

def write_input(player, prev_board, curr_board, input_path='input.txt'):
    """
    Write the current game state to the input file for the player.

    Args:
        player (int): Current player's color (1 for Black, 2 for White).
        prev_board (numpy.ndarray): Previous board state.
        curr_board (numpy.ndarray): Current board state.
        input_path (str): Path to the input file to be written.
    """
    with open(input_path, 'w') as f:
        f.write(f"{player}\n")
        for row in prev_board:
            f.write(''.join(map(str, row.tolist())) + '\n')
        for row in curr_board:
            f.write(''.join(map(str, row.tolist())) + '\n')

def is_move_valid(prev_board, curr_board, player, move):
    """
    Check if a move is valid, including suicide and Ko rules.

    Args:
        prev_board (numpy.ndarray): Previous board state.
        curr_board (numpy.ndarray): Current board state.
        player (int): Current player's color.
        move (tuple): Move to validate.

    Returns:
        bool: True if the move is valid, False otherwise.

    Note:
        Currently a placeholder that assumes all moves are valid.
    """
    return True  # Placeholder implementation

def remove_dead_stones(board, player):
    """
    Remove stones of the specified player that have no liberties.

    Args:
        board (numpy.ndarray): Current board state.
        player (int): Player color whose dead stones are to be removed.

    Returns:
        int: Number of stones removed.
    """
    removed = 0
    for i in range(BOARD_SIZE):
        for j in range(BOARD_SIZE):
            if board[i][j] == player and not has_liberty(board, i, j):
                board[i][j] = 0
                removed += 1
    return removed

def has_liberty(board, x, y):
    """
    Check if the stone at (x, y) has at least one liberty.

    Args:
        board (numpy.ndarray): Current board state.
        x (int): X-coordinate of the stone.
        y (int): Y-coordinate of the stone.

    Returns:
        bool: True if the stone or its group has at least one liberty, False otherwise.
    """
    player = board[x][y]
    if player == 0:
        return False
    visited = set()
    stack = [(x, y)]
    while stack:
        i, j = stack.pop()
        if (i, j) in visited:
            continue
        visited.add((i, j))
        for dx, dy in [(-1,0),(1,0),(0,-1),(0,1)]:  # Directions: up, down, left, right
            ni, nj = i + dx, j + dy
            if 0 <= ni < BOARD_SIZE and 0 <= nj < BOARD_SIZE:
                if board[ni][nj] == 0:
                    return True  # Found a liberty
                elif board[ni][nj] == player and (ni, nj) not in visited:
                    stack.append((ni, nj))
    return False

def calculate_winner(final_board):
    """
    Calculate the winner based on the final board state.

    Args:
        final_board (numpy.ndarray): Final board state after the game ends.

    Returns:
        int: 1 if Black wins, 2 if White wins.
    """
    black_stones = np.sum(final_board == 1)
    white_stones = np.sum(final_board == 2)

    # Calculate total scores
    black_score = black_stones
    white_score = white_stones + KOMI

    if black_score > white_score:
        return 1  # Black wins
    else:
        return 2  # White wins

def play_game(agent_command, opponent_command, agent_as_black=True):
    """
    Conduct a single game between the agent and an opponent.

    Args:
        agent_command (str): Command to run the agent.
        opponent_command (str): Command to run the opponent.
        agent_as_black (bool): True if the agent plays as Black, False as White.

    Returns:
        int: Winner of the game (1 for Black, 2 for White).
    """
    prev_board = initialize_board()
    curr_board = initialize_board()
    move_number = 0
    consecutive_passes = 0
    player_turn = 1 if agent_as_black else 2  # 1: Black, 2: White
    winner = None

    # Reset any persistent files from previous games
    for filename in ['step_num.txt', 'output.txt', 'step.txt', 'mystep.txt']:
        if os.path.exists(filename):
            os.remove(filename)

    while move_number < MAX_MOVES:
        move_number += 1
        opponent = 3 - player_turn  # Switch player: 1 <-> 2
        if player_turn == 1:
            current_command = agent_command if agent_as_black else opponent_command
        else:
            current_command = opponent_command if agent_as_black else agent_command

        # Write current game state to input file
        write_input(player_turn, prev_board, curr_board)

        # Execute the current player's command
        try:
            subprocess.run(current_command, timeout=TIME_LIMIT, shell=True)
        except subprocess.TimeoutExpired:
            winner = opponent
            print(f"Player {player_turn} exceeded time limit.")
            break
        except Exception as e:
            winner = opponent
            print(f"Error running player {player_turn}'s code: {e}")
            break

        # Read the move from the player's output
        move = read_output()
        if move is None:
            winner = opponent
            print(f"Player {player_turn} made an invalid move.")
            break

        # Process the move
        if move != 'PASS':
            # Validate move coordinates
            if not (0 <= move[0] < BOARD_SIZE and 0 <= move[1] < BOARD_SIZE):
                winner = opponent
                print(f"Invalid move coordinates: {move}")
                print(f"Previous Board:\n{prev_board}")
                print(f"Current Board:\n{curr_board}")
                print(f"Player {player_turn} made an invalid move.")
                break
            # Check if the position is already occupied
            if curr_board[move[0]][move[1]] != 0:
                winner = opponent
                print(f"Player {player_turn} placed on an occupied position: {move}")
                break
            # Update the board with the new move
            new_board = np.copy(curr_board)
            new_board[move[0]][move[1]] = player_turn

            # Remove opponent's dead stones
            opponent_player = 2 if player_turn == 1 else 1
            captured = remove_dead_stones(new_board, opponent_player)
            # Optional: Record the number of captured stones if needed

            # Validate the move (suicide and Ko rules)
            if not is_move_valid(prev_board, new_board, player_turn, move):
                winner = opponent
                print(f"Player {player_turn} made an illegal move.")
                break

            # Update the previous and current boards
            prev_board = np.copy(curr_board)
            curr_board = new_board
            consecutive_passes = 0
        else:
            consecutive_passes += 1
            if consecutive_passes >= 2:
                # Two consecutive PASS moves end the game
                break
            # Update the previous board without changing the current board
            prev_board = np.copy(curr_board)

        # Remove 'output.txt' to prevent confusion in the next move
        if os.path.exists('output.txt'):
            os.remove('output.txt')

        # Switch turns to the opponent
        player_turn = opponent

    # Determine the winner if not already decided
    if winner is None:
        winner = calculate_winner(curr_board)
        # Optional: Print the final board for debugging
        # print(f"Final Board:\n{curr_board}")
    return winner

def run_agent_vs_opponent(agent_params, opponent_command):
    """
    Run a series of games between the agent and a specific opponent.

    Args:
        agent_params (tuple): Tuple of agent parameters (C, D, E, G, H).
        opponent_command (str): Command to run the opponent.

    Returns:
        int: Number of games won by the agent.
    """
    C, D, E, G, H = agent_params

    # Construct the agent command with parameters
    agent_command = f'python3 player.py {C} {D} {E} {G} {H}'

    # Play as Black
    winner_black = play_game(agent_command, opponent_command, agent_as_black=True)

    # Play as White
    winner_white = play_game(agent_command, opponent_command, agent_as_black=False)

    # Count agent wins
    agent_wins = 0
    if winner_black == 1:
        agent_wins += 1
    if winner_white == 2:
        agent_wins += 1

    return agent_wins

def main():
    """
    Main function to perform parameter optimization using Optuna.
    It runs multiple games with different parameter sets and selects the top-performing ones.
    """
    # Dictionary to store performance details for each parameter set
    performance_details = {}

    # Define the objective function for Optuna
    def objective(trial):
        """
        Optuna's objective function to maximize the agent's overall win rate.

        Args:
            trial (optuna.trial.Trial): A trial object for suggesting parameters.

        Returns:
            float: Negative of the overall win rate (since Optuna minimizes by default).
        """
        # Sample parameters from the defined search space
        C = trial.suggest_float('C', 0.0, 10.0)
        D = trial.suggest_float('D', 0.0, 10.0)
        E = trial.suggest_float('E', 0.0, 10.0)
        G = trial.suggest_float('G', -10.0, 0.0)
        H = trial.suggest_float('H', 0.0, 10.0)
        agent_params = (C, D, E, G, H)

        print(f"\nTesting Parameters: C={C:.2f}, D={D:.2f}, E={E:.2f}, G={G:.2f}, H={H:.2f}")

        total_wins = 0
        performance_per_opponent = {}

        # Iterate over all opponents
        for opponent_idx, opponent_command in enumerate(OPPONENT_COMMANDS, 1):
            agent_wins = 0
            # Play multiple games against each opponent
            for game_num in range(1, GAMES_PER_COMBINATION + 1):
                agent_wins += run_agent_vs_opponent(agent_params, opponent_command)
            # Calculate win rate
            win_rate = agent_wins / (GAMES_PER_COMBINATION * 2)  # Two games per combination (Black and White)
            total_wins += agent_wins
            opponent_name = os.path.basename(opponent_command).replace('.py', '')
            performance_per_opponent[opponent_name] = win_rate
            # Optional: Print opponent-specific win rate
            # print(f"    Opponent {opponent_idx} ({opponent_name}) Win Rate: {win_rate * 100:.2f}%")

        # Calculate overall win rate across all opponents and games
        total_games = len(OPPONENT_COMMANDS) * GAMES_PER_COMBINATION * 2
        overall_win_rate = total_wins / total_games

        # Save performance details
        performance_details[agent_params] = performance_per_opponent

        # Write intermediate results to prevent data loss in case of interruptions
        performance_str = ' '.join([f"{opponent}:{win_rate:.5f}" for opponent, win_rate in performance_per_opponent.items()])
        result_str = f"{C:.5f} {D:.5f} {E:.5f} {G:.5f} {H:.5f} {overall_win_rate:.2f}\n"

        with open("mid_result.txt", "a") as f:
            f.write(result_str)

        # Return negative win rate for minimization
        return -overall_win_rate

    # Create an Optuna study object with a Tree-structured Parzen Estimator sampler
    study = optuna.create_study(direction='minimize', sampler=optuna.samplers.TPESampler(seed=42))

    print("Starting Bayesian Optimization with Optuna...")

    # Optimize the objective function with a specified number of trials
    study.optimize(objective, n_trials=500)  # Adjust n_trials as needed

    # Extract all evaluated parameter sets and their scores
    evaluated_params = study.trials_dataframe()[['params_C', 'params_D', 'params_E', 'params_G', 'params_H']].values
    evaluated_scores = [-score for score in study.trials_dataframe()['value'].values]

    # Combine parameters with their overall win rates
    param_winrate = list(zip(evaluated_params, evaluated_scores))

    # Sort parameter sets by win rate in descending order
    param_winrate_sorted = sorted(param_winrate, key=lambda x: x[1], reverse=True)

    # Select the top N parameter sets
    top_10_params = param_winrate_sorted[:TOP_N]

    # Prepare details for the top N parameter sets
    top_10_details = []

    for params, win_rate in top_10_params:
        agent_params = tuple(params)
        opponent_performance = performance_details.get(agent_params, {})
        top_10_details.append({
            'Parameters': agent_params,
            'Overall Win Rate': win_rate,
            'Performance per Opponent': opponent_performance
        })

    # Save the top N parameter sets and their performance to a file
    with open('top_10_parameters.txt', 'w') as f:
        for idx, detail in enumerate(top_10_details, 1):
            params = detail['Parameters']
            overall = detail['Overall Win Rate']
            opponent_perf = detail['Performance per Opponent']
            f.write(f"Top {idx} Parameter Set:\n")
            f.write(f"  C={params[0]:.5f}, D={params[1]:.5f}, E={params[2]:.5f}, G={params[3]:.5f}, H={params[4]:.5f}\n")
            f.write(f"  Overall Win Rate: {overall * 100:.2f}%\n")
            for opponent_name, opp_win_rate in opponent_perf.items():
                f.write(f"    Opponent ({opponent_name}) Win Rate: {opp_win_rate * 100:.2f}%\n")
            f.write("\n")

    # Save all optimization results to a separate file
    with open('optimization_results.txt', 'w') as f:
        for idx, (params, win_rate) in enumerate(param_winrate_sorted, 1):
            agent_params = tuple(params)
            f.write(f"Rank {idx}:\n")
            f.write(f"  Parameters: C={params[0]:.5f}, D={params[1]:.5f}, E={params[2]:.5f}, G={params[3]:.5f}, H={params[4]:.5f}\n")
            f.write(f"  Overall Win Rate: {win_rate * 100:.2f}%\n")
            opponent_perf = performance_details.get(agent_params, {})
            for opponent_name, opp_win_rate in opponent_perf.items():
                f.write(f"    Opponent ({opponent_name}) Win Rate: {opp_win_rate * 100:.2f}%\n")
            f.write("\n")

if __name__ == "__main__":
    """
    Entry point of the script.
    Starts the optimization process and measures execution time.
    """
    start_time = time.time()
    print("start")
    main()
    print(f"\nExecution time: {time.time() - start_time:.2f} seconds")